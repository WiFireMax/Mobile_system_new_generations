<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="ru">
<head>
<!-- Generated by javadoc -->
<title>SocketType (JeroMQ 0.6.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="SocketType (JeroMQ 0.6.0 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":9,"i2":9,"i3":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SocketType.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#enum.constant.summary">Enum Constants</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#enum.constant.detail">Enum Constants</a>&nbsp;|&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.zeromq</a></div>
<h2 title="Enum SocketType" class="title">Enum SocketType</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true" title="class or interface in java.lang" class="externalLink">java.lang.Enum</a>&lt;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a>&gt;</li>
<li>
<ul class="inheritance">
<li>org.zeromq.SocketType</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io" class="externalLink">Serializable</a></code>, <code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html?is-external=true" title="class or interface in java.lang" class="externalLink">Comparable</a>&lt;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a>&gt;</code></dd>
</dl>
<hr>
<pre>public enum <span class="typeNameLabel">SocketType</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true" title="class or interface in java.lang" class="externalLink">Enum</a>&lt;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a>&gt;</pre>
<div class="block">Socket Type enumeration</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Isa Hekmatizadeh</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ENUM CONSTANT SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="enum.constant.summary">
<!--   -->
</a>
<h3>Enum Constant Summary</h3>
<table class="memberSummary">
<caption><span>Enum Constants</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Enum Constant</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CHANNEL">CHANNEL</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify CHANNEL socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CLIENT">CLIENT</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify CLIENT socket.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#DEALER">DEALER</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify a DEALER socket (aka XREQ).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#DISH">DISH</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify DISH socket.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#GATHER">GATHER</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify GATHER socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#PAIR">PAIR</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify a exclusive pair of sockets.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#PEER">PEER</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify PEER socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#PUB">PUB</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify a PUB socket, receiving side must be a SUB or XSUB.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#PULL">PULL</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify the receiving part of a PUSH socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#PUSH">PUSH</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify a PUSH socket, receiving side must be a PULL.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#RADIO">RADIO</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify RADIO socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#RAW">RAW</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify RAW socket.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#REP">REP</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify the receiving part of a REQ or DEALER socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#REQ">REQ</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify a REQ socket, receiving side must be a REP or ROUTER.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ROUTER">ROUTER</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify ROUTER socket (aka XREP).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SCATTER">SCATTER</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify SCATTER socket.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SERVER">SERVER</a></span></code></th>
<td class="colLast">
<div class="block">
 Flag to specify SERVER socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STREAM">STREAM</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify a STREAM socket.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SUB">SUB</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify the receiving part of the PUB or XPUB socket.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#XPUB">XPUB</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify a XPUB socket, receiving side must be a SUB or XSUB.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#XSUB">XSUB</a></span></code></th>
<td class="colLast">
<div class="block">Flag to specify the receiving part of the PUB or XPUB socket.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#type">type</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#type()">type</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static <a href="SocketType.html" title="enum in org.zeromq">SocketType</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#type(int)">type</a></span>&#8203;(int&nbsp;baseType)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="SocketType.html" title="enum in org.zeromq">SocketType</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#valueOf(java.lang.String)">valueOf</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;name)</code></th>
<td class="colLast">
<div class="block">Returns the enum constant of this type with the specified name.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="SocketType.html" title="enum in org.zeromq">SocketType</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#values()">values</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns an array containing the constants of this enum type, in
the order they are declared.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Enum">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true" title="class or interface in java.lang" class="externalLink">Enum</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#clone--" title="class or interface in java.lang" class="externalLink">clone</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#compareTo-E-" title="class or interface in java.lang" class="externalLink">compareTo</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang" class="externalLink">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#finalize--" title="class or interface in java.lang" class="externalLink">finalize</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#getDeclaringClass--" title="class or interface in java.lang" class="externalLink">getDeclaringClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#hashCode--" title="class or interface in java.lang" class="externalLink">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#name--" title="class or interface in java.lang" class="externalLink">name</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#ordinal--" title="class or interface in java.lang" class="externalLink">ordinal</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#toString--" title="class or interface in java.lang" class="externalLink">toString</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html?is-external=true#valueOf-java.lang.Class-java.lang.String-" title="class or interface in java.lang" class="externalLink">valueOf</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#getClass--" title="class or interface in java.lang" class="externalLink">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notify--" title="class or interface in java.lang" class="externalLink">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="class or interface in java.lang" class="externalLink">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait--" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="class or interface in java.lang" class="externalLink">wait</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ENUM CONSTANT DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="enum.constant.detail">
<!--   -->
</a>
<h3>Enum Constant Detail</h3>
<a id="PAIR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PAIR</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> PAIR</pre>
<div class="block"><p>Flag to specify a exclusive pair of sockets.</p>

 A socket of type PAIR can only be connected to a single peer at any one time.
 <br>
 No message routing or filtering is performed on messages sent over a PAIR socket.
 <br>
 When a PAIR socket enters the mute state due to having reached the high water mark for the connected peer,
 or if no peer is connected, then any send() operations on the socket shall block until the peer becomes available for sending;
 messages are not discarded.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td>PAIR</td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Incoming routing strategy</td><td>N/A</td></tr>
 <tr><td>Outgoing routing strategy</td><td>N/A</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table>
 <p>
 <strong>PAIR sockets are designed for inter-thread communication across the inproc transport
 and do not implement functionality such as auto-reconnection.
 PAIR sockets are considered experimental and may have other missing or broken aspects.</strong></div>
</li>
</ul>
<a id="PUB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PUB</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> PUB</pre>
<div class="block"><p>Flag to specify a PUB socket, receiving side must be a SUB or XSUB.</p>

 A socket of type PUB is used by a publisher to distribute data.
 <br>
 Messages sent are distributed in a fan out fashion to all connected peers.
 <br>
 The <a href="ZMQ.Socket.html#recv()"><code>ZMQ.Socket.recv()</code></a> function is not implemented for this socket type.
 <br>
 When a PUB socket enters the mute state due to having reached the high water mark for a subscriber,
 then any messages that would be sent to the subscriber in question shall instead be dropped until the mute state ends.
 <br>
 The send methods shall never block for this socket type.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#SUB"><code>ZMQ.SUB</code></a>, <a href="ZMQ.html#XSUB"><code>ZMQ.XSUB</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Send only</td></tr>
 <tr><td>Incoming routing strategy</td><td>N/A</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Fan out</td></tr>
 <tr><td>Action in mute state</td><td>Drop</td></tr>
 </table></div>
</li>
</ul>
<a id="SUB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SUB</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> SUB</pre>
<div class="block"><p>Flag to specify the receiving part of the PUB or XPUB socket.</p>

 A socket of type SUB is used by a subscriber to subscribe to data distributed by a publisher.
 <br>
 Initially a SUB socket is not subscribed to any messages,
 use the <a href="ZMQ.Socket.html#subscribe(byte%5B%5D)"><code>ZMQ.Socket.subscribe(byte[])</code></a> option to specify which messages to subscribe to.
 <br>
 The send methods are not implemented for this socket type.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#PUB"><code>ZMQ.PUB</code></a>, <a href="ZMQ.html#XPUB"><code>ZMQ.XPUB</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Receive only</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Outgoing routing strategy</td><td>N/A</td></tr>
 </table></div>
</li>
</ul>
<a id="REQ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REQ</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> REQ</pre>
<div class="block"><p>Flag to specify a REQ socket, receiving side must be a REP or ROUTER.</p>

 A socket of type REQ is used by a client to send requests to and receive replies from a service.
 <br>
 This socket type allows only an alternating sequence of send(request) and subsequent recv(reply) calls.
 <br>
 Each request sent is round-robined among all services, and each reply received is matched with the last issued request.
 <br>
 If no services are available, then any send operation on the socket shall block until at least one service becomes available.
 <br>
 The REQ socket shall not discard messages.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#REP"><code>ZMQ.REP</code></a>, <a href="ZMQ.html#ROUTER"><code>ZMQ.ROUTER</code></a></td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Send, Receive, Send, Receive, ...</td></tr>
 <tr><td>Incoming routing strategy</td><td>Last peer</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Round-robin</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table></div>
</li>
</ul>
<a id="REP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REP</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> REP</pre>
<div class="block"><p>Flag to specify the receiving part of a REQ or DEALER socket.</p>

 A socket of type REP is used by a service to receive requests from and send replies to a client.
 <br>
 This socket type allows only an alternating sequence of recv(request) and subsequent send(reply) calls.
 <br>
 Each request received is fair-queued from among all clients, and each reply sent is routed to the client that issued the last request.
 <br>
 If the original requester does not exist any more the reply is silently discarded.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#REQ"><code>ZMQ.REQ</code></a>, <a href="ZMQ.html#DEALER"><code>ZMQ.DEALER</code></a></td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Receive, Send, Receive, Send, ...</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Last peer</td></tr>
 </table></div>
</li>
</ul>
<a id="DEALER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DEALER</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> DEALER</pre>
<div class="block"><p>Flag to specify a DEALER socket (aka XREQ).</p>

 DEALER is really a combined ventilator / sink
 that does load-balancing on output and fair-queuing on input
 with no other semantics. It is the only socket type that lets
 you shuffle messages out to N nodes and shuffle the replies
 back, in a raw bidirectional asynch pattern.
 <br>
 A socket of type DEALER is an advanced pattern used for extending request/reply sockets.
 <br>
 Each message sent is round-robined among all connected peers, and each message received is fair-queued from all connected peers.
 <br>
 When a DEALER socket enters the mute state due to having reached the high water mark for all peers,
 or if there are no peers at all, then any send() operations on the socket shall block
 until the mute state ends or at least one peer becomes available for sending; messages are not discarded.
 <br>
 When a DEALER socket is connected to a <a href="ZMQ.html#REP"><code>ZMQ.REP</code></a> socket each message sent must consist of
 an empty message part, the delimiter, followed by one or more body parts.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#ROUTER"><code>ZMQ.ROUTER</code></a>, <a href="ZMQ.html#REP"><code>ZMQ.REP</code></a>, <a href="ZMQ.html#DEALER"><code>ZMQ.DEALER</code></a></td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Round-robin</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table></div>
</li>
</ul>
<a id="ROUTER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ROUTER</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> ROUTER</pre>
<div class="block"><p>Flag to specify ROUTER socket (aka XREP).</p>

 ROUTER is the socket that creates and consumes request-reply
 routing envelopes. It is the only socket type that lets you route
 messages to specific connections if you know their identities.
 <br>
 A socket of type ROUTER is an advanced socket type used for extending request/reply sockets.
 <br>
 When receiving messages a ROUTER socket shall prepend a message part containing the identity
 of the originating peer to the message before passing it to the application.
 <br>
 Messages received are fair-queued from among all connected peers.
 <br>
 When sending messages a ROUTER socket shall remove the first part of the message
 and use it to determine the identity of the peer the message shall be routed to.
 If the peer does not exist anymore the message shall be silently discarded by default,
 unless <a href="ZMQ.Socket.html#setRouterMandatory(boolean)"><code>ZMQ.Socket.setRouterMandatory(boolean)</code></a> socket option is set to true.
 <br>
 When a ROUTER socket enters the mute state due to having reached the high water mark for all peers,
 then any messages sent to the socket shall be dropped until the mute state ends.
 <br>
 Likewise, any messages routed to a peer for which the individual high water mark has been reached shall also be dropped,
 unless <a href="ZMQ.Socket.html#setRouterMandatory(boolean)"><code>ZMQ.Socket.setRouterMandatory(boolean)</code></a> socket option is set to true.
 <br>
 When a <a href="ZMQ.html#REQ"><code>ZMQ.REQ</code></a> socket is connected to a ROUTER socket, in addition to the identity of the originating peer
 each message received shall contain an empty delimiter message part.
 <br>
 Hence, the entire structure of each received message as seen by the application becomes: one or more identity parts,
 delimiter part, one or more body parts.
 <br>
 When sending replies to a REQ socket the application must include the delimiter part.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#DEALER"><code>ZMQ.DEALER</code></a>, <a href="ZMQ.html#REQ"><code>ZMQ.REQ</code></a>, <a href="ZMQ.html#ROUTER"><code>ZMQ.ROUTER</code></a></td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Outgoing routing strategy</td><td>See text</td></tr>
 <tr><td>Action in mute state</td><td>Drop (See text)</td></tr>
 </table></div>
</li>
</ul>
<a id="PULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PULL</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> PULL</pre>
<div class="block"><p>Flag to specify the receiving part of a PUSH socket.</p>

 A socket of type ZMQ_PULL is used by a pipeline node to receive messages from upstream pipeline nodes.
 <br>
 Messages are fair-queued from among all connected upstream nodes.
 <br>
 The send() function is not implemented for this socket type.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#PUSH"><code>ZMQ.PUSH</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Receive only</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Outgoing routing strategy</td><td>N/A</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table></div>
</li>
</ul>
<a id="PUSH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PUSH</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> PUSH</pre>
<div class="block"><p>Flag to specify a PUSH socket, receiving side must be a PULL.</p>

 A socket of type PUSH is used by a pipeline node to send messages to downstream pipeline nodes.
 <br>
 Messages are round-robined to all connected downstream nodes.
 <br>
 The recv() function is not implemented for this socket type.
 <br>
 When a PUSH socket enters the mute state due to having reached the high water mark for all downstream nodes,
 or if there are no downstream nodes at all, then any send() operations on the socket shall block until the mute state ends
 or at least one downstream node becomes available for sending; messages are not discarded.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#PULL"><code>ZMQ.PULL</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Send only</td></tr>
 <tr><td>Incoming routing strategy</td><td>N/A</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Round-robin</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table></div>
</li>
</ul>
<a id="XPUB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>XPUB</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> XPUB</pre>
<div class="block"><p>Flag to specify a XPUB socket, receiving side must be a SUB or XSUB.</p>

 Subscriptions can be received as a message. Subscriptions start with
 a '1' byte. Unsubscriptions start with a '0' byte.
 <br>
 Same as <a href="ZMQ.html#PUB"><code>ZMQ.PUB</code></a> except that you can receive subscriptions from the peers in form of incoming messages.
 <br>
 Subscription message is a byte '1' (for subscriptions) or byte '0' (for unsubscriptions) followed by the subscription body.
 <br>
 Messages without a sub/unsub prefix are also received, but have no effect on subscription status.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#SUB"><code>ZMQ.SUB</code></a>, <a href="ZMQ.html#XSUB"><code>ZMQ.XSUB</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Send messages, receive subscriptions</td></tr>
 <tr><td>Incoming routing strategy</td><td>N/A</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Fan out</td></tr>
 <tr><td>Action in mute state</td><td>Drop</td></tr>
 </table></div>
</li>
</ul>
<a id="XSUB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>XSUB</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> XSUB</pre>
<div class="block"><p>Flag to specify the receiving part of the PUB or XPUB socket.</p>

 Same as <a href="ZMQ.html#SUB"><code>ZMQ.SUB</code></a> except that you subscribe by sending subscription messages to the socket.
 <br>
 Subscription message is a byte '1' (for subscriptions) or byte '0' (for unsubscriptions) followed by the subscription body.
 <br>
 Messages without a sub/unsub prefix may also be sent, but have no effect on subscription status.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="ZMQ.html#PUB"><code>ZMQ.PUB</code></a>, <a href="ZMQ.html#XPUB"><code>ZMQ.XPUB</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Receive messages, send subscriptions</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Outgoing routing strategy</td><td>N/A</td></tr>
 <tr><td>Action in mute state</td><td>Drop</td></tr>
 </table></div>
</li>
</ul>
<a id="STREAM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STREAM</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> STREAM</pre>
<div class="block"><p>Flag to specify a STREAM socket.</p>

 A socket of type STREAM is used to send and receive TCP data from a non-ØMQ peer, when using the tcp:// transport.
 A STREAM socket can act as client and/or server, sending and/or receiving TCP data asynchronously.
 <br>
 When receiving TCP data, a STREAM socket shall prepend a message part containing the identity
 of the originating peer to the message before passing it to the application.
 <br>
 Messages received are fair-queued from among all connected peers.
 When sending TCP data, a STREAM socket shall remove the first part of the message
 and use it to determine the identity of the peer the message shall be routed to,
 and unroutable messages shall cause an EHOSTUNREACH or EAGAIN error.
 <br>
 To open a connection to a server, use the <a href="ZMQ.Socket.html#connect(java.lang.String)"><code>ZMQ.Socket.connect(String)</code></a> call, and then fetch the socket identity using the <a href="ZMQ.Socket.html#getIdentity()"><code>ZMQ.Socket.getIdentity()</code></a> call.
 To close a specific connection, send the identity frame followed by a zero-length message.
 When a connection is made, a zero-length message will be received by the application.
 Similarly, when the peer disconnects (or the connection is lost), a zero-length message will be received by the application.
 The <a href="ZMQ.html#SNDMORE"><code>ZMQ.SNDMORE</code></a> flag is ignored on data frames. You must send one identity frame followed by one data frame.
 <br>
 Also, please note that omitting the SNDMORE flag will prevent sending further data (from any client) on the same socket.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td>none</td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Outgoing routing strategy</td><td>See text</td></tr>
 <tr><td>Action in mute state</td><td>EAGAIN</td></tr>
 </table></div>
</li>
</ul>
<a id="CLIENT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CLIENT</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> CLIENT</pre>
<div class="block"><p>Flag to specify CLIENT socket.</p>

 <p>The CLIENT socket type talks to one or more SERVER peers. If connected to multiple peers, it scatters sent
 messages among these peers in a round-robin fashion. On reading, it reads fairly, from each peer in turn. It is
 reliable, insofar as it does not drop messages in normal cases.</p>

 <p>If the CLIENT socket has established a connection, send operations will accept messages, queue them, and send
 them as rapidly as the network allows. The outgoing buffer limit is defined by the high water mark for the
 socket. If the outgoing buffer is full, or if there is no connected peer, send operations will block, by default.
 The CLIENT socket will not drop messages.</p>

 <p>
  CLIENT sockets are threadsafe.
  They do not accept the ZMQ_SNDMORE option on sends not ZMQ_RCVMORE on receives.
  This limits them to single part data.
  The intention is to extend the API to allow scatter/gather of multi-part data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="#SERVER"><code>SERVER</code></a></td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Round Robin</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table></div>
</li>
</ul>
<a id="SERVER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SERVER</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> SERVER</pre>
<div class="block"><p>
 Flag to specify SERVER socket.
 </p>
 <p>
 The SERVER socket type talks to zero or more CLIENT peers. Each outgoing message is sent to a specific peer
 CLIENT. A SERVER socket can only reply to an incoming message: the CLIENT peer must always initiate a
 conversation.
 </p>
 <p>
 Each received message has a routing_id that is a 32-bit unsigned integer. To send a message to a given CLIENT
 peer the application must set the peer’s routing_id on the message.
 </p>
 <p>
  SERVER sockets are threadsafe.
  They do not accept the ZMQ_SNDMORE option on sends not ZMQ_RCVMORE on receives.
  This limits them to single part data.
  The intention is to extend the API to allow scatter/gather of multi-part data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="#CLIENT"><code>CLIENT</code></a></td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Outgoing routing strategy</td><td>See text</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Action in mute state</td><td>Fail</td></tr>
 </table></div>
</li>
</ul>
<a id="RADIO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RADIO</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> RADIO</pre>
<div class="block"><p>Flag to specify RADIO socket.</p>
 <p>
 The radio-dish pattern is used for one-to-many distribution of data from a single publisher to multiple subscribers in a fan out fashion.
 Radio-dish is using groups (vs Pub-sub topics), Dish sockets can join a group and each message sent by Radio sockets belong to a group.
 </p>
 <p>
 Groups are strings limited to 16 chars length (including null).
 The intention is to increase the length to 40 chars (including null).
 The encoding of groups shall be UTF8.
 Groups are matched using exact matching (vs prefix matching of PubSub).
 </p>
 <p>A socket of type RADIO is used by a publisher to distribute data.
 Each message belong to a group, a group is specified with <a href="ZFrame.html#setGroup(java.lang.String)"><code>ZFrame.setGroup(String)</code></a>.
 Messages are distributed to all members of a group.
 The <a href="ZMQ.Socket.html#recv(int)"><code>ZMQ.Socket.recv(int)</code></a> function is not implemented for this socket type.
 </p>
 <p>When a RADIO socket enters the mute state due to having reached the high water mark for a subscriber,
 then any messages that would be sent to the subscriber in question shall instead be dropped
 until the mute state ends. The <a href="ZMQ.Socket.html#send(byte%5B%5D,int)"><code>ZMQ.Socket.send(byte[], int)</code></a> function shall never block for this socket type.
 </p>
 <p>
 NOTE: RADIO sockets are threadsafe.
 They do not accept the ZMQ_SNDMORE option on sends.
 This limits them to single part data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="#DISH"><code>DISH</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Send only</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Fan out</td></tr>
 <tr><td>Incoming routing strategy</td><td>N/A</td></tr>
 <tr><td>Action in mute state</td><td>Drop</td></tr>
 </table>
 <p>
 NOTE: RADIO is still in draft phase.
 </p></div>
</li>
</ul>
<a id="DISH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DISH</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> DISH</pre>
<div class="block"><p>Flag to specify DISH socket.</p>

 <p>
 The radio-dish pattern is used for one-to-many distribution of data from a single publisher to multiple subscribers in a fan out fashion.
 Radio-dish is using groups (vs Pub-sub topics), Dish sockets can join a group and each message sent by Radio sockets belong to a group.
 </p>
 <p>
 Groups are strings limited to 16 chars length (including null).
 The intention is to increase the length to 40 chars (including null).
 The encoding of groups shall be UTF8.
 Groups are matched using exact matching (vs prefix matching of PubSub).
 </p>

 A socket of type DISH is used by a subscriber to subscribe to groups distributed by a radio.
 Initially a DISH socket is not subscribed to any groups, use <a href="ZMQ.Socket.html#join(java.lang.String)"><code>ZMQ.Socket.join(String)</code></a> to join a group.
 To get the group the message belong, call <a href="ZFrame.html#getGroup()"><code>ZFrame.getGroup()</code></a>.
 The <a href="ZMQ.Socket.html#send(byte%5B%5D,int)"><code>ZMQ.Socket.send(byte[], int)</code></a> function is not implemented for this socket type.

 <p>
 NOTE: DISH sockets are threadsafe.
 They do not accept ZMQ_RCVMORE on receives.
 This limits them to single part data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="#RADIO"><code>RADIO</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Receive only</td></tr>
 <tr><td>Outgoing routing strategy</td><td>N/A</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 </table>
 NOTE: DISH is still in draft phase.</div>
</li>
</ul>
<a id="CHANNEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHANNEL</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> CHANNEL</pre>
<div class="block"><p>Flag to specify CHANNEL socket.</p>
 <p>
 The channel pattern is the thread-safe version of the exclusive pair pattern.
 The channel pattern is used to connect a peer to precisely one other peer.
 This pattern is used for inter-thread communication across the inproc transport.
 </p>
 <p>
 A socket of type 'CHANNEL' can only be connected to a single peer at any one
 time.  No message routing or filtering is performed on messages sent over a
 'CHANNEL' socket.
 </p>
 <p>
 When a 'CHANNEL' socket enters the 'mute' state due to having reached the
 high water mark for the connected peer, or, for connection-oriented transports,
 if the ZMQ_IMMEDIATE option is set and there is no connected peer, then
 any <a href="ZMQ.Socket.html#send(byte%5B%5D,int)"><code>ZMQ.Socket.send(byte[], int)</code></a> operations on the socket shall block until the peer
 becomes available for sending; messages are not discarded.
 </p>
 <p>
 While 'CHANNEL' sockets can be used over transports other than 'inproc',
 their inability to auto-reconnect coupled with the fact new incoming connections will
 be terminated while any previous connections (including ones in a closing state)
 exist makes them unsuitable for TCP in most cases.
 </p>
 <p>
 NOTE: 'CHANNEL' sockets are designed for inter-thread communication across
 the 'inproc' transport and do not implement functionality such
 as auto-reconnection.
 </p>
 <p>
 NOTE: 'CHANNEL' sockets are threadsafe. They do not accept ZMQ_RCVMORE on receives.
 This limits them to single part data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td>CHANNEL</td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Outgoing routing strategy</td><td>N/A</td></tr>
 <tr><td>Incoming routing strategy</td><td>N/A</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table>
 <p>
 NOTE: CHANNEL is still in draft phase.
 </p></div>
</li>
</ul>
<a id="PEER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PEER</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> PEER</pre>
<div class="block"><p>Flag to specify PEER socket.
 </p>
 <p>
 A 'PEER' socket talks to a set of 'PEER' sockets.
 </p>
 <p>
 To connect and fetch the 'routing_id' of the peer use <a href="ZMQ.Socket.html#connectPeer(java.lang.String)"><code>ZMQ.Socket.connectPeer(String)</code></a>.
 </p>
 <p>
 Each received message has a 'routing_id' that is a 32-bit unsigned integer.
 The application can fetch this with <a href="ZFrame.html#getRoutingId()"><code>ZFrame.getRoutingId()</code></a>.
 </p>
 <p>
 To send a message to a given 'PEER' peer the application must set the peer's
 'routing_id' on the message, using <a href="ZFrame.html#setRoutingId(int)"><code>ZFrame.setRoutingId(int)</code></a>.
 </p>
 <p>
 If the 'routing_id' is not specified, or does not refer to a connected client
 peer, the send call will fail with EHOSTUNREACH. If the outgoing buffer for
 the peer is full, the send call shall block, unless ZMQ_DONTWAIT is
 used in the send, in which case it shall fail with EAGAIN. The 'PEER'
 socket shall not drop messages in any case.
 </p>
 <p>
 NOTE: 'PEER' sockets are threadsafe. They do not accept the ZMQ_SNDMORE
 option on sends not ZMQ_RCVMORE on receives. This limits them to single part
 data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td>PEER</td></tr>
 <tr><td>Direction</td><td>Bidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Unrestricted</td></tr>
 <tr><td>Outgoing routing strategy</td><td>See text</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Action in mute state</td><td>Return EAGAIN</td></tr>
 </table>
 NOTE: PEER is still in draft phase.</div>
</li>
</ul>
<a id="RAW">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RAW</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> RAW</pre>
<div class="block"><p>Flag to specify RAW socket.</p></div>
</li>
</ul>
<a id="SCATTER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SCATTER</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> SCATTER</pre>
<div class="block"><p>Flag to specify SCATTER socket.
 </p>
 <p>
 The scatter-gather pattern is the thread-safe version of the pipeline pattern.
 The scatter-gather pattern is used for distributing data to nodes arranged in a pipeline.
 Data always flows down the pipeline, and each stage of the pipeline
 is connected to at least one node.
 When a pipeline stage is connected to multiple nodes data is round-robined among all connected nodes.
 </p>
 <p>
 When a 'SCATTER' socket enters the 'mute' state due to having reached the
 high water mark for all downstream nodes, or, for connection-oriented transports,
 if the ZMQ_IMMEDIATE option is set and there are no downstream nodes at all,
 then any <a href="ZMQ.Socket.html#send(byte%5B%5D,int)"><code>ZMQ.Socket.send(byte[], int)</code></a> operations on the socket shall block until the mute
 state ends or at least one downstream node becomes available for sending;
 messages are not discarded.
 </p>
 <p>
 NOTE: 'SCATTER' sockets are threadsafe. They do not accept ZMQ_RCVMORE on receives.
 This limits them to single part data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="#GATHER"><code>GATHER</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Send only</td></tr>
 <tr><td>Outgoing routing strategy</td><td>Round-robin</td></tr>
 <tr><td>Incoming routing strategy</td><td>N/A</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table>
 NOTE: SCATTER is still in draft phase.</div>
</li>
</ul>
<a id="GATHER">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>GATHER</h4>
<pre>public static final&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a> GATHER</pre>
<div class="block"><p>Flag to specify GATHER socket.
 </p>
 <p>
 The scatter-gather pattern is the thread-safe version of the pipeline pattern.
 The scatter-gather pattern is used for distributing data to nodes arranged in a pipeline.
 Data always flows down the pipeline, and each stage of the pipeline
 is connected to at least one node.
 When a pipeline stage is connected to multiple nodes data is round-robined among all connected nodes.
 </p>
 <p>
 A socket of type 'GATHER' is used by a scatter-gather node to receive messages
 from upstream scatter-gather nodes. Messages are fair-queued from among all
 connected upstream nodes. The <a href="ZMQ.Socket.html#send(byte%5B%5D,int)"><code>ZMQ.Socket.send(byte[], int)</code></a> function is not implemented for
 this socket type.
 </p>
 <p>
 NOTE: 'GATHER' sockets are threadsafe. They do not accept ZMQ_RCVMORE on receives.
 This limits them to single part data.
 <p>
 <table border="1">
 <caption><strong>Summary of socket characteristics</strong></caption>
 <tr><td>Compatible peer sockets</td><td><a href="#SCATTER"><code>SCATTER</code></a></td></tr>
 <tr><td>Direction</td><td>Unidirectional</td></tr>
 <tr><td>Send/receive pattern</td><td>Receive only</td></tr>
 <tr><td>Outgoing routing strategy</td><td>N/A</td></tr>
 <tr><td>Incoming routing strategy</td><td>Fair-queued</td></tr>
 <tr><td>Action in mute state</td><td>Block</td></tr>
 </table>
 NOTE: SCATTER is still in draft phase.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ FIELD DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="type">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>type</h4>
<pre>public final&nbsp;int type</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="values()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>values</h4>
<pre class="methodSignature">public static&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a>[]&nbsp;values()</pre>
<div class="block">Returns an array containing the constants of this enum type, in
the order they are declared. This method may be used to iterate
over the constants as follows:
<pre>
for (SocketType c : SocketType.values())
&nbsp;   System.out.println(c);
</pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array containing the constants of this enum type, in the order they are declared</dd>
</dl>
</li>
</ul>
<a id="valueOf(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>valueOf</h4>
<pre class="methodSignature">public static&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a>&nbsp;valueOf&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;name)</pre>
<div class="block">Returns the enum constant of this type with the specified name.
The string must match <i>exactly</i> an identifier used to declare an
enum constant in this type.  (Extraneous whitespace characters are 
not permitted.)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>name</code> - the name of the enum constant to be returned.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the enum constant with the specified name</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if this enum type has no constant with the specified name</dd>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html?is-external=true" title="class or interface in java.lang" class="externalLink">NullPointerException</a></code> - if the argument is null</dd>
</dl>
</li>
</ul>
<a id="type(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>type</h4>
<pre class="methodSignature">public static&nbsp;<a href="SocketType.html" title="enum in org.zeromq">SocketType</a>&nbsp;type&#8203;(int&nbsp;baseType)</pre>
</li>
</ul>
<a id="type()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>type</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;type()</pre>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SocketType.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#enum.constant.summary">Enum Constants</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#enum.constant.detail">Enum Constants</a>&nbsp;|&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 1970. All rights reserved.</small></p>
</footer>
</body>
</html>
